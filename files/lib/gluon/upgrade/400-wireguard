#!/usr/bin/lua
local site = require 'gluon.site_config'
local users = require 'gluon.users'
local util = require 'gluon.util'

local uci = require('simple-uci').cursor()

-- -- Group for iptables rule
-- users.add_group('gluon-fastd', 800)


local enabled = uci:get('wireguard', 'wireguard', 'enabled')
if not enabled then
  enabled = site.wireguard.enabled or false
end

-- local syslog_level = uci:get('fastd', 'mesh_vpn', 'syslog_level') or 'verbose'

-- local methods

-- if site.fastd_mesh_vpn.configurable then
--
--  local has_null = util.contains(site.fastd_mesh_vpn.methods, 'null')
--
--  local old_methods = uci:get('fastd', 'mesh_vpn', 'method')
--  if old_methods then
--    has_null = util.contains(old_methods, 'null')
--  end

--  methods = {}
--  if has_null then
--    table.insert(methods, 'null')
--  end

--  for _, method in ipairs(site.fastd_mesh_vpn.methods) do
--    if method ~= 'null' then
--      table.insert(methods, method)
--    end
--  end

-- else
--  methods = site.fastd_mesh_vpn.methods
-- end


uci:section('wireguard', 'wireguard', 'wireguard', {
	enabled='1'
	iface='wg0'
	v6='1'
	v4='0'
	batman='1'
	secret=''
	port='10099'
})
-- secret has to be set and saved to file by another script (it has to be in a file because wg need it)

-- delete old mesh servers regardless everything, that also means that changes are not upgradesave
-- uci:delete_all('wireguard', 'peer',
--    function(peer)
--      return (peer.net == 'peer' and peer.group == name)
--    end
--  )

-- wireguard.mesh1=peer
-- wireguard.mesh1.PublicKey='Gqntn/96zfRrz6SedcNXzw7b+vyjn6IfZlFM8+6U63E='
-- enabled='1'
-- wireguard.mesh1.Endpoint='136.243.153.228:10099'
-- wireguard.mesh1.AllowedIps='0.0.0.0/0,::/0'

-- HELP NEEDED ... i dunno how to automate the wireguard = { peer = { mesh1 = { allthenicethings
-- for mesh1 to mesh<whatever>
--local function addpeer(PublicKey, enabled, Endpoint, AllowedIps)
--	uci section('wireguard','peer', name
--		{
--			PublicKey = site.wireguard. .. name .. .PublicKey,
--			enabled = site.wireguard. .. name .. .enabled,
--			gretapip = site.wireguard. .. name .. .enabled,
--			Endpoint = site.wireguard. .. name .. .Endpoint,
--			AllowedIps = site.wireguard. .. name .. .AllowedIps,
--		}
--	),
--end

-- do it by hand 
uci section('wireguard','peer', 'mesh1', {
	PublicKey = site.wireguard.mesh1.PublicKey,
	enabled = site.wireguard.mesh1.enabled,
	gretapip = site.wireguard.mesh1.enabled,
	Endpoint = site.wireguard.mesh1.Endpoint,
	AllowedIps = site.wireguard.mesh1.AllowedIps,
	}
)

add_groups('wireguard', site.wireguard.peer)

uci:save('wireguard')

-- i dont know if the following is needed, because we use main script
-- and also we need the ip6gretap stuff which may be a different if
-- uci:section('network', 'interface', 'wg0',
--  {
--    ifname = site.wireguard.wireguard.if,
--    proto = 'wireguard',
--    transitive = true,
--    fixed_mtu = true,
--    macaddr = util.generate_mac(7),
--  }
-- )
-- uci:save('network')

-- we may want some iptable/firewall rules




-- local add_groups

--local function add_peer(group, name, config)
--  uci:section('fastd', 'peer', group .. '_peer_' .. name,
--    {
--      enabled = true,
--      net = 'mesh_vpn',
--      group = group,
--      key = config.key,
--      remote = config.remotes,
--    }
--  )
--end

--local function add_group(name, config, parent)
--  uci:delete('fastd', name)
--  uci:delete_all('fastd', 'peer',
--    function(peer)
--      return (peer.net == 'mesh_vpn' and peer.group == name)
--    end
--  )


--  uci:section('fastd', 'peer_group', name,
--    {
--      enabled = true,
--      net = 'mesh_vpn',
--      parent = parent,
--      peer_limit = config.limit,
--    }
--  )

--  if config.peers then
--    for peername, peerconfig in pairs(config.peers) do
--      add_peer(name, peername, peerconfig)
--    end
--  end

--  add_groups(name, config.groups, name)
--end

-- declared local above
--function add_groups(prefix, groups, parent)
--  if groups then
--    for name, group in pairs(groups) do
--      add_group(prefix .. '_' .. name, group, parent)
--    end
--  end
--end
